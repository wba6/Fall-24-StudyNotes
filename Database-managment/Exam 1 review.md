# Introduction to Database Systems

### Transactional data:
**Structured data** created with an organization, with sizes ranging from gigabytes to terabytes. 
Transactional data refers to structured data generated by day-to-day operations within an organization. This type of data typically involves records of transactions such as purchases, bookings, or customer interactions.

### Big data
Data generated by **multimedia applications** and internet of things.
Big data differs from transactional data in the following four ways:
- Volume: How much data at rest terabytes to exabytes
- Velocity: Data in motion / streaming data, milliseconds to seconds to respond
- Variety: Data in many forms, structured unstructed, text, multimedia 
- Veracity: Data in doubt or uncertainty due to data inconsistency  

### Examples of transactional data

The Ohio department of motor vehicles processes vehicle registrations, drivers licenses, and traffic violations for 26 million drivers. Assume each driver creates 4 transactions per year at 1000 bytes per transaction, on average, and 5 years of data are stored in a database.

**Bank Transactions**:
- A customer makes a payment or withdrawal from a bank account.
- Fields recorded might include:
    - Account Number
    - Transaction Date and Time
    - Transaction Amount
    - Transaction Type (Deposit, Withdrawal, Transfer)
    - Balance after Transaction
    
**Retail Sales**:
- When a customer buys products in a store, transactional data would include:
    - Purchase ID
    - Customer ID
    - Product ID
    - Quantity purchased
    - Price
    - Date and Time of Purchase
### Examples of big data 

Youtube users view approximately 4 million videos per minutes worldwide. Youtube tracks all views and information about video content to optimize advertising shown to each user. Assume youtube stores approximately 10,000 bytes per view annually.

**Social Media Data**
- **Description**: Platforms like Facebook, Twitter, Instagram, and LinkedIn generate vast amounts of data every second.
- **Components**:
    - **User Posts and Comments**: Text, images, videos, and other multimedia content.
    - **User Interactions**: Likes, shares, retweets, and reactions.
    - **Metadata**: Timestamps, geolocation data, and device information.
- **Use Cases**:
    - Sentiment analysis to gauge public opinion.
    - Targeted advertising based on user behavior and preferences.
    - Trend analysis to identify popular topics.
    
**Internet of Things (IoT) Data**
- **Description**: Devices connected to the internet, such as smart thermostats, wearable fitness trackers, and industrial sensors, continuously generate data.
- **Components**:
    - **Sensor Readings**: Temperature, humidity, motion, and other environmental metrics.
    - **Device Logs**: Operational data from machinery and equipment.
    - **User Interactions**: Data from smart home devices controlled by users.
- **Use Cases**:
    - Predictive maintenance in manufacturing to prevent equipment failures.
    - Smart city applications like traffic management and energy consumption optimization.
    - Health monitoring through wearable devices.

### Database systems
**Database**: A very large collection of interrelated data
Models a real-world enterprise:
- Entities/Objects
- Relationships
A **database management system** is a software system designed to store, manage, and facilitate access to databases.

### Why use databases
In the early days file systems were used but that have some drawbacks:
- Data redundancy
- Difficulty sorting and accessing data ( no api)
- Data isolation( no standard format) and lack of security 
- Integrity problems ( cannot control input data such as account > 0)
- Concurrency problems

So we use databases to solve some of those problems here are some advantages behind them:
- Data independence ( primary key / unique)
- Efficient data access
- Data integrity and security 
- Concurrent access, and crash recovery

But databases did also have some drawbacks such as:
- Expensive and complicated to maintain 
- They are not suited for special purpose tasks ( keyword search)

### Schemas 

A **schema** is the logical structure of the database
An **instance** is the actual content of the database

**Database** = collection of relationships / tables
**Relation schema** = relation name and attribute list. (Optionally data types)
**Database schema** = set of all relation relation schema in the database 

# SQL - Structured Query Language
SQL is designed for managing data held in a relational database management system. SQL consists of a **data definition language** and a **data manipulation language**.

**Two main components of SQL**:
1. Data Definition Language
	- This is for tables such as creating, altering or dropping
2. Data Manipulation Language 
	- This is for data such as insert, update, delete, and select

**Creating, Dropping, and adding a column to  a table**:
```
//Create table
CREATE TABLE <table_name> (<List of elements>);

//Delete table
DROP TABLE <table_name>;

//Add a column but not changing data
ALTER TABLE <table_name> ADD <column_name> datatype;
```

### Elements of table declarations

**Data types**
- INT or INTEGER
- REAL or FLOAT
- CHAR(n) - fixed length n
- VARCHAR(n) - variable length string up to n

**Any** value can be **NULL** 

**Declaring Keys** 
- Tables can have at most one primary key
- Can have more than one unique key
- No attribute of PRIMARY KEY can ever be NULL
- UNIQUE keys can have a NULL value

**Example of creating a table with a primary key** 
```
CREATE TABLE Beers (
	name CHAR(20) PRIMARY KEY,
	manf CHAR(20)
)
```

**Example of Multi-attribute Key**
```
CREATE TABLE Sells (
	bar CHAR(20),
	beer VARCHAR(20),
	price REAL,
	PRIMARY KEY (bar, beer)
)
```



# Relational Algebra

**Core Relational Algebra**
- **Selection**: Picking certain rows
- **Projection**: Picking certain columns
- **Products and joins**: Composition of relations
- **Renaming**: of relations and attributes
- **Union, intersection and difference**: Usual set operations, but both operands must have the same relational schema.


**Selection**:
- Picks certain rows

Example of selection:

| bar   | beer   | price |
|-------|--------|-------|
| Joe's | Bud    | 2.50  |
| Joe's | Miller | 2.75  |
| Sue's | Bud    | 2.50  |
| Sue's | Miller | 3.00  |

JoeMenue := σ_bar="Joe's"(Sells)

| bar   | beer   | price |
|-------|--------|-------|
| Joe's | Bud    | 2.50  |
| Joe's | Miller | 2.75  |


**Projection**:
- Projects the current query to pick out certain columns
- Eliminate duplicate tuples

Example of projection

| bar   | beer   | price |
|-------|--------|-------|
| Joe's | Bud    | 2.50  |
| Joe's | Miller | 2.75  |
| Sue's | Bud    | 2.50  |
| Sue's | Miller | 3.00  |

Prices := π_beer, price(Sells)

| beer   | price |
|--------|-------|
| Bud    | 2.50  |
| Miller | 2.75  |
| Miller | 3.00  |

**Product**:
- Not often used
- Pair each tuple from T1 with each tuple of T2

Example of product 
R1:

| A | B |
|---|---|
| 1 | 2 |
| 3 | 4 |

R2:

| B | C  |
|---|----|
| 5 | 6  |
| 7 | 8  |
| 9 | 10 |

R3: (Result of R1 ⨯ R2)

| A | R1.B | R2.B | C  |
|---|------|------|----|
| 1 | 2    | 5    | 6  |
| 1 | 2    | 7    | 8  |
| 1 | 2    | 9    | 10 |
| 3 | 4    | 5    | 6  |
| 3 | 4    | 7    | 8  |
| 3 | 4    | 9    | 10 |

**Theta-join** 
- Take the product of R1 X R2 then apply selection to result
- Often natural join would be a better choice 

Example of Theta-join
Sells:

| bar   | beer   | price |
|-------|--------|-------|
| Joe's | Bud    | 2.50  |
| Joe's | Miller | 2.75  |
| Sue's | Bud    | 2.50  |
| Sue's | Coors  | 3.00  |

Bars:

| name   | addr        |
|--------|-------------|
| Joe's  | Maple St.   |
| Sue's  | River Rd.   |

BarInfo := Sells ⨝ Bars
*Join on Sells.bar = Bars.name*

BarInfo:

| bar   | beer   | price | name   | addr        |
|-------|--------|-------|--------|-------------|
| Joe's | Bud    | 2.50  | Joe's  | Maple St.   |
| Joe's | Miller | 2.75  | Joe's  | Maple St.   |
| Sue's | Bud    | 2.50  | Sue's  | River Rd.   |
| Sue's | Coors  | 3.00  | Sue's  | River Rd.   |

**Natural Join**:
- Equating attributes of the same name
- Projecting out one copy of each pair of equated attributes

Example of natural join:
Sells:

| bar   | beer    | price |
|-------|---------|-------|
| Joe's | Bud     | 2.50  |
| Joe's | Miller  | 2.75  |
| Sue's | Bud     | 2.50  |
| Sue's | Coors   | 3.00  |

Bars:

| bar    | addr        |
|--------|-------------|
| Joe's  | Maple St.   |
| Sue's  | River Rd.   |

BarInfo := Sells ⟕ Bars
*Left outer join (⟕) between Sells and Bars*

BarInfo:

| bar   | beer    | price | addr        |
|-------|---------|-------|-------------|
| Joe's | Bud     | 2.50  | Maple St.   |
| Joe's | Miller  | 2.75  | Maple St.   |
| Sue's | Bud     | 2.50  | River Rd.   |
| Sue's | Coors   | 3.00  | River Rd.   |

**Theta join vs natural join** 
The **natural join** (`R ⨝ S`) automatically joins two relations `R` and `S` by equating all attributes with the same name in both relations. It implicitly uses equality conditions for every pair of attributes with the same name, and it removes one copy of the duplicate attributes in the result.

On the other hand, the **theta-join** (`R ⨝_C S`) allows for an explicit join condition `C` to be specified. In this case, the condition is `R.A = S.A` for each attribute `A` that appears in both `R` and `S`. While this might seem the same as a natural join, the key difference is that the theta-join does not automatically remove duplicate attributes. Both attributes `R.A` and `S.A` will appear in the result unless explicitly projected away.

Summary of Differences:
- **Natural Join (`R ⨝ S`)**: Implicitly joins on attributes with the same name, removes duplicates.
- **Theta-Join (`R ⨝_C S`)**: Requires an explicit condition and does not remove duplicates unless specified.

**Renaming**
- Renames a table and attribute 

Example of Renaming
Bars:

| name   | addr        |
|--------|-------------|
| Joe's  | Maple St.   |
| Sue's  | River Rd.   |

R(bar, addr) := Bars

R:

| bar    | addr        |
|--------|-------------|
| Joe's  | Maple St.   |
| Sue's  | River Rd.   |


For **Union**, **Intersection**, and **difference** the schema of both sets must be the same

**Precedence of relational operators:**
1. [σ, π, ρ] (highest).
2. [⨯, ⨝].
3. ∩.
4. [∪, −].

### Relational Algebra vs SQL
 - Relational Algebra treats relations as sets (ie duplicates will never occur)
 - Duplicate elimination is explicit in SQL(Select Distinct)


# SQL 

